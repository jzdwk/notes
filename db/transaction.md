# transaction 
项目中需要使用分布式事务，借此对事务、锁、分布式事务方案、知名开源项目进行分析和总结。因为不同的DB对于事务/锁的实现方式不同。在此仅总结Mysql InnoDB的实现。
## base


## latch

## lock

DB使用锁，是为了支持对共享资源的并发访问，提供数据的**完整性**和**一致性**。

InnoDB实现了2个标准的**行级锁**：
1. 共享锁 S Lock：可并发读，阻塞其他事务的写
2. 排他锁 X Lock: 只可单条写，阻塞其他事务的读、写

### 意向锁

以上是针对单行数据的，另外由于InnoDB支持**多粒度锁定**，也就是说，对于一张表，表上可以有表锁（比如drop table时添加），也可以有上段中的行锁。所以，为了*优化加锁*操作，提出了**意向锁**， 即，要向某条数据加锁（S/X），先要在其上层资源添加（IS/IX），意向锁为**表级别的锁，和表锁同级**：
1. 意向共享锁IS Lock：事务向获取一张表中的某行共享锁
2. 意向共享锁IX Lock：事务向获取一张表中的某行共享锁

IS/IX/S/X之间的兼容性自行百度。总结来说：
1. IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。
2. 行级别的X和S按照普通的共享、排他规则即可。

**存在的意义**：

1. 在mysql中有表锁: LOCK TABLE my_tabl_name READ; 用读锁锁表，会阻塞其他事务修改表数据/LOCK TABLE my_table_name WRITe; 用写锁锁表，会阻塞其他事务读和写.
2. Innodb引擎又支持行锁
3. 锁共存时，事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。**数据库要怎么判断这个冲突呢？**

步骤一：判断表是否已被其他事务用表锁锁表（表锁检测）
步骤二：判断表中的每一行是否已被行锁锁住。*这样的判断方法效率实在不高，因为需要遍历整个表。于是就有了意向锁，即优化加锁操作*在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。在意向锁存在的情况下，上面的判断可以改成step1：不变step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。

### 锁相关命令

1. `SHOW ENGINE INNODB STATUS` 查看存储引擎状态
2. `SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;` 查看事务状态
3. `SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;` 查看锁状态
4. `SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;` 查看阻塞的事务和相关锁信息

### 一致性非锁定读

**行为**：如果读取的数据正在执行DELETE/UPDATE这种需要X LOCK 行锁资源的操作，如果使用一致性非锁定读，那么读操作不会等待X LOCK的释放。而是去读该行的一个**快照**。
**目的**：可以极大提高数据库并发性。
**实现**：InnoDB通过**多版本并发控制（MVCC）**实现。快照数据是当前行数据的一个历史版本，并且每行记录可以有不止一个快照。另外，这个快照由**回滚段(undo,回忆db引擎的表/段/区/页/行)**去实现，因此，快照数据本身没有开销。

在RC以及RR（默认）的事务隔离级别下，InnoDB使用非锁定的一致性读。而这两种级别对应的读快照的行为不同：
1. RC下，总是读取最新的一份快照，这样，在另一个事务提交数据后，因为最新的快照是另一个事务更新后的，所以会读到。因此RC叫做读已提交。
2. RR下，总是读取此事务开始时的数据，此时，在另一个事务提交数据后，因为要读的快照是本次事务开始时的，所以不会读到另一个事务提交后的数据。因此RR叫做可重复读。